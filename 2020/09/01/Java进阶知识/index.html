<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java进阶知识 | old engineer</title><meta name="description" content="JUC相关线程有哪几种状态New、Runnable、Blocked、Timed_Waiting、Waiting、Terminated【6种，出去开始和终结，有4中】 run()、start()方法的区别start()是开启一个线程；run()是一个普通方法，程序会顺序执行   并发、并行的区别并发既多个线程访问同一个资源并行既多个线程同时处理多个任务   volatile关键字的理解volatil"><meta name="keywords" content="JAVA进阶"><meta name="author" content="叶中中"><meta name="copyright" content="叶中中"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/09/01/Java%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Java进阶知识"><meta property="og:url" content="http://yoursite.com/2020/09/01/Java%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"><meta property="og:site_name" content="old engineer"><meta property="og:description" content="JUC相关线程有哪几种状态New、Runnable、Blocked、Timed_Waiting、Waiting、Terminated【6种，出去开始和终结，有4中】 run()、start()方法的区别start()是开启一个线程；run()是一个普通方法，程序会顺序执行   并发、并行的区别并发既多个线程访问同一个资源并行既多个线程同时处理多个任务   volatile关键字的理解volatil"><meta property="og:image" content="http://117.50.98.206/images/wallpaper_drop_ocean.jpg"><meta property="article:published_time" content="2020-09-01T06:10:54.000Z"><meta property="article:modified_time" content="2020-09-01T10:07:10.217Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-01 18:07:10'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-film"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC%E7%9B%B8%E5%85%B3"><span class="toc-text">JUC相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">线程有哪几种状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#run-%E3%80%81start-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">run()、start()方法的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">并发、并行的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">volatile关键字的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E4%B8%8EReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">synchronized与ReentrantLock的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-%E5%92%8Csleep-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">wait()和sleep()的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM%E2%80%94%E2%80%94JAVA-Memory-Model-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">JMM——JAVA Memory Model,java内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%B8%AD%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">java中锁的种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-text">阻塞队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E7%9B%B8%E5%85%B3"><span class="toc-text">JVM相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%88%86%E5%8C%BA"><span class="toc-text">JVM分区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="toc-text">如何判断对象是否存活？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E7%9B%B8%E5%85%B3"><span class="toc-text">GC相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%8F%82%E6%95%B0"><span class="toc-text">JVM参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%88%86%E7%B1%BB"><span class="toc-text">引用分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3CPU100-%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-text">怎么解决CPU100%的情况？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3full-GC%E9%A2%91%E7%B9%81%EF%BC%9F"><span class="toc-text">怎么解决full GC频繁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">类的生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88String%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">为什么String不可变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class-forName-%E5%92%8CClassLoader-loadClass-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Class.forName()和ClassLoader.loadClass()有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">动态代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-text">容器相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E7%9B%B8%E5%85%B3"><span class="toc-text">Linux相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%9B%B8%E5%85%B3"><span class="toc-text">Redis相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="toc-text">redis为什么快</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">redis数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E8%83%BD%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88"><span class="toc-text">redis能用来干什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">redis分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-text">redis过期策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-text">redis持久化方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">读写一致性问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql"><span class="toc-text">mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88Innodb%EF%BC%89"><span class="toc-text">聚簇索引（Innodb）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#B-%E6%A0%91%E5%92%8CB%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB-B-%E6%A0%91%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">B+树和B树的区别,B+树的优势</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">spring生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-text">一致性哈希算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka"><span class="toc-text">Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#kafka%E6%80%8E%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%90%9E%E5%90%90%E9%87%8F%E9%AB%98"><span class="toc-text">kafka怎么为什么吞吐量高</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">kafka如何保证高可用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-text">kafka如何保证消息不被重复消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kafka%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F"><span class="toc-text">kafka怎么保证顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kafka%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-text">kafka消息丢失问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%AE%B5%E5%BC%8F-PC"><span class="toc-text">两段式(PC)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AE%B5%E5%BC%8F-TCC"><span class="toc-text">三段式(TCC)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7-%E5%88%A9%E7%94%A8%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">最终一致性(利用消息中间件)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dubbo%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">Dubbo的工作流程和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%8610%E5%B1%82%EF%BC%9A%E9%87%8C%E9%9D%A2%E4%B8%8A%E9%9D%A2%E5%85%AD%E5%B1%82%E5%9C%A8dubbo%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%89%80%E6%89%AE%E6%BC%94%E7%9A%84%E8%A7%92%E8%89%B2%E3%80%82"><span class="toc-text">分10层：里面上面六层在dubbo工作中所扮演的角色。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%8C%82%E4%BA%86%EF%BC%8Cprovider%E5%92%8Cconsumer%E8%BF%98%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E9%80%9A%E4%BF%A1%E4%B9%88%EF%BC%9F"><span class="toc-text">注册中心挂了，provider和consumer还可以继续通信么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dubbo%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8"><span class="toc-text">Dubbo泛化调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B2%A1%E6%9C%89%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E3%80%82"><span class="toc-text">饿汉模式，代码如下，不存在线程安全问题，但是没有延迟加载。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AD%98%E5%9C%A8%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E7%94%A8DCL%E8%A7%A3%E5%86%B3"><span class="toc-text">懒汉模式，延迟加载，但是存在，线程安全问题，用DCL解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%EF%BC%8CDCL%E7%89%88%E6%9C%AC"><span class="toc-text">懒汉模式，DCL版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%A7%B0%E4%B8%BA%E6%9C%80%E4%BD%B3%E6%96%B9%E6%A1%88"><span class="toc-text">静态内部类，可以称为最佳方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%EF%BC%8C%E6%B0%B8%E8%BF%9C%E5%8D%95%E4%BE%8B"><span class="toc-text">枚举，永远单例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">类加载机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal"><span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%9D%E9%95%96%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">保镖的问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%A3%E7%A2%91%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-text">口碑面试问题</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(http://117.50.98.206/images/wallpaper_drop_ocean.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">old engineer</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-film"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java进阶知识</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-01T06:10:54.000Z" title="发表于 2020-09-01 14:10:54">2020-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-01T10:07:10.217Z" title="更新于 2020-09-01 18:07:10">2020-09-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="JUC相关"><a href="#JUC相关" class="headerlink" title="JUC相关"></a>JUC相关</h1><h2 id="线程有哪几种状态"><a href="#线程有哪几种状态" class="headerlink" title="线程有哪几种状态"></a>线程有哪几种状态</h2><p>New、Runnable、Blocked、Timed_Waiting、Waiting、Terminated【6种，出去开始和终结，有4中】<br><img src="http://117.50.98.206/images/java_thread_status_trans.png" alt="image"></p>
<h2 id="run-、start-方法的区别"><a href="#run-、start-方法的区别" class="headerlink" title="run()、start()方法的区别"></a>run()、start()方法的区别</h2><p>start()是开启一个线程；run()是一个普通方法，程序会顺序执行  </p>
<h2 id="并发、并行的区别"><a href="#并发、并行的区别" class="headerlink" title="并发、并行的区别"></a>并发、并行的区别</h2><p>并发既多个线程访问同一个资源<br>并行既多个线程同时处理多个任务  </p>
<h2 id="volatile关键字的理解"><a href="#volatile关键字的理解" class="headerlink" title="volatile关键字的理解"></a>volatile关键字的理解</h2><p>volatile是一个轻量级的同步机制，主要有两个特性</p>
<ul>
<li>保证内存可见性</li>
<li>防止指令重新排序<br>注意，volatile不保证原子性</li>
</ul>
<h2 id="synchronized与ReentrantLock的区别"><a href="#synchronized与ReentrantLock的区别" class="headerlink" title="synchronized与ReentrantLock的区别"></a>synchronized与ReentrantLock的区别</h2><ul>
<li>synchronized是jvm实现的；ReentrantLock是JDK实现的</li>
<li>synchronized不可中断；ReentrantLock不可中断</li>
<li>synchronized是非公平锁；ReentrantLock可以在构造方法中指定是否公平</li>
<li>synchronized不能绑定多个Condition；ReentrantLock 可以同时绑定多个 Condition</li>
</ul>
<h2 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h2><ul>
<li>wait()、notify()、notifyAll()是Object的方法；sleep()是Thread的方法</li>
<li>wait()方法会释放锁;sleep()方法不会释放锁</li>
</ul>
<h2 id="JMM——JAVA-Memory-Model-java内存模型"><a href="#JMM——JAVA-Memory-Model-java内存模型" class="headerlink" title="JMM——JAVA Memory Model,java内存模型"></a>JMM——JAVA Memory Model,java内存模型</h2><p>java内存模型是一个抽象概念，用于规定程序中各个变量的访问方式，是多线程执行正确性的约束规范。由于jvm运行程序的实体是线程，JVM创建线程时会为其创建一个工作内存，既栈，用于储存线程的私有数据。而java线程模型规定所有的变量都储存在主内存中，主内存是共享区域，但线程对变量的操作必须在工作内存中进行，所以首先要将主内存的变量复制到工作内存，对变量进行操作后再回写到主内存。模型如下:<br><img src="http://117.50.98.206/images/JMM_simple.jpg" alt="image"><br>粗略来说可以认为JMM中的主内存对应Java内存区域划分中的堆、方法区，JMM中的工作内存对应Java内存区域划分中的栈、程序计数器  </p>
<p>这样的架构之下可以预见会存在一定的安全问题，为了解决此类问题，因此JMM定义了三大特性原子性、有序性、可见性，如synchronized、volatile、ReentrantLock等等  </p>
<p>之所以说volatile轻量就是因为volatile只保证了可见性、有序性而不保证原子性</p>
<p><strong>hapen before原则</strong></p>
<ul>
<li>程序顺序规则。既单个线程中代码执行顺序会以代码编写顺序为准，虽然会有指令重排，但指令重排对单线程并无影响</li>
<li>锁定规则。既对同一个锁的unlock操作发生于对同一个锁的lock操作之前</li>
<li>volatile变量规则。对volatile变量的写操作发生于此变量的读操作之前。如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则。Thread对象的start()方法发生于此线程的所以其他方法之前。</li>
<li>线程中断规则。一个线程调用另外一个线程的interrupt()方法发生于被中断线程检测到中断之前。</li>
<li>线程终结规则。线程的所有操作都发生于线程终结之前</li>
<li>对象终结规则。一个对象的构造方法发生于执行finalize()方法之前</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>compare and swap,既比较并交换;cas有三个参数：实际值、期望值和新值。期望值与实际值相同则把实际值替换为新值。<br>原理：自旋、unsafe类<br>以AtomicInteger举例。AtomicInteger在初始化时会获取UnSafe类的实例unsafe，一个用volatile修饰的int值value，value的偏移量valueoffset。<br><img src="http://117.50.98.206/images/AtomicInteger_1.png" alt="image"></p>
<p>调用getAndIncrement()源码如下<br><img src="http://117.50.98.206/images/AtomicInteger_2.png" alt="image"><br><img src="http://117.50.98.206/images/AtomicInteger_3.png" alt="image"><br>getIntVolatile(var1, var2)，这是个native方法,其实就是获取var1中，var2偏移量处的值。var1就是AtomicInteger对象，var2就是我们前面提到的valueOffset，这样我们就从内存里获取到现在valueOffset处的值。</p>
<p>compareAndSwapInt（var1, var2, var5, var5 + var4）其实换成compareAndSwapInt（obj, offset, expect, update）比较清楚，意思就是如果obj内的value和expect相等，就证明没有其他线程改变过这个变量，那么就更新它为update，如果这一步的CAS没有成功，那就采用<strong>自旋</strong>的方式继续进行CAS操作，取出乍一看这也是两个步骤了啊，<strong>其实在JNI里是借助于一个CPU指令完成的，是原子操作</strong></p>
<p>缺点:</p>
<ul>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作</li>
<li>ABA问题<br>规避ABA问题可以使用AtomicReference+版本号，或者AtomicStampedReference</li>
</ul>
<h2 id="java中锁的种类"><a href="#java中锁的种类" class="headerlink" title="java中锁的种类"></a>java中锁的种类</h2><p><img src="http://117.50.98.206/images/java_lock_category_tree.png" alt="image"></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">https://tech.meituan.com/2018/11/15/java-lock.html</a>  </p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池核心参数:</p>
<ul>
<li>corepoolsize:核心线程数</li>
<li>maxpoolsize:最大线程数</li>
<li>keepAliveTime:超过核心线程数的线程【额外线程】最大空闲时间，超过此时间的空闲线程会被回收</li>
<li>timeunit:keepaliveTime的时间单位</li>
<li>queue:阻塞队列。当任务超过核心线程数时，任务会在阻塞队列中等待，阻塞队列满了则继续创建线程(最大为maxpoolsize)</li>
<li>threadFactory:创建线程的工厂，一般用来设置线程名</li>
<li>RejectedExecutionHandler：线程池已满、且阻塞队列已满时的拒绝策略  </li>
</ul>
<p>拒绝策略:</p>
<ul>
<li>AbortPolicy:丢弃任务并抛出RejectedExecutionException异常(默认)</li>
<li>DiscardPolicy:也是丢弃任务，但是不抛出异常</li>
<li>DiscardOldestPolicy:丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>
<li>CallerRunsPolicy:由调用线程处理该任务 </li>
</ul>
<p>自带线程池缺点</p>
<ul>
<li>Execurors.newSingleThreadExecutor:核心线程数、最大线程数均为1，但阻塞队列长度是无限，容易OOM</li>
<li>Execurors.newFixedThreadPool:核心线程数、最大线程数是一样的的，但阻塞队列长度是无限，容易OOM</li>
<li>newCachedThreadPool：核心线程数是1，但最大线程数是int最大值，阻塞队列长度为1，容易OOM</li>
</ul>
<p>应使用new ThreadPoolExecutors(corePoolSize,maxPoolSize,aliveTime,timeunit,blockingQueue)手动创建</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p><img src="http://117.50.98.206/images/block_queue.png" alt="image"></p>
<ul>
<li>ArrayBlockingQueue:一个由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ul>
<h1 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h1><p>提到JVM首先就要想到四种垃圾回收算法、七种垃圾收集器</p>
<p>再要记住GC有两种：minor GC发生在新生代，Full GC是整个堆发生GC<br>四种垃圾回收算法:</p>
<ul>
<li>标记清除算法</li>
<li>复制算法</li>
<li>标记整理算法</li>
<li>分代收集算法</li>
</ul>
<p>七种垃圾收集器:<br>新生代:serial收集器、ParNew收集器、Parallel Scavenge收集器<br>老年代:serail old收集器、Parallel Old收集器、CMS收集器<br>其他:G1收集器  </p>
<h2 id="JVM分区"><a href="#JVM分区" class="headerlink" title="JVM分区"></a>JVM分区</h2><p>JVM分为堆、虚拟机栈、本地方法栈、程序计数器、方法区  </p>
<p>需要注意的是metaspace(元空间)，元空间与永久代类似，对应jvm中的方法区，需要注意的是元空间使用的并非是jvm中空间，而是使用物理内存  </p>
<h2 id="如何判断对象是否存活？"><a href="#如何判断对象是否存活？" class="headerlink" title="如何判断对象是否存活？"></a>如何判断对象是否存活？</h2><p>引用计数法、可达性分析算法。现代虚拟机都使用可达性分析算法  </p>
<p>可达性分析算法从GC Roots开始寻找对象，寻找对象的路径称作引用链，如果一个对象没有通过引用链与GC Roots相连，则说明此对象已死亡<br>怎么确定GC Roots?<br>GC Roots有四类:</p>
<ul>
<li>栈中引用指向的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中native方法引用的对象</li>
</ul>
<p>由于遍历所有的GC Roots耗时很长，所以虚拟机维护了一个OopMap用于在特定的时刻(安全点)记录下对象的引用，以达到快速检测对象的目的。</p>
<h2 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a>GC相关</h2><p><strong>minor GC</strong>:发生在新生代，采用复制算法。虚拟机把新生代划分法eden、s1、s2三个部分，比例为8:1:1，新生代每次只是用eden和其中一块survivor区域。新创建的对象在eden区，发生GC时存活的对象复制到其中一个suivivor区，并给对象计数；当对象的计数超过15次则被移动到老年代</p>
<p><strong>full GC</strong>:发生在整个堆。新生代使用复制算法，老年代使用标记整理算法。</p>
<h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><p>jvm参数分为三种:  </p>
<ul>
<li>标配参数,java -version,java -help之类</li>
<li>X参数(了解) -Xint -Xcomp -Xmixed<ul>
<li>XX参数 </li>
<li>boolean类型:+表示开启,-表示关闭;-XX:+UseCompressedOops</li>
<li>KV设置类型:-XX:OldSize=89653248;-Xms等等</li>
</ul>
</li>
</ul>
<p>小知识点jvm工具</p>
<ul>
<li>jps查看java进程</li>
<li>jinfo $pid 查看java进程信息(能看到jvm参数等等配置信息)</li>
<li>jstack 查看jvm运行信息(可用于排查死锁)</li>
<li>jmap dump内存进行分析</li>
<li>jstat 查看gc相关信息</li>
</ul>
<h2 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h2><ul>
<li>强引用:gc时强引用指向的对象不会被回收，就算内存不足程序终止也不会</li>
<li>软引用:如果内存充足时，软引用指向的对象不会被回收；但内存不足时会回收软引用指向的对象</li>
<li>弱引用:gc时会回收弱引用指向的对象</li>
<li>虚引用:虚引用不会对对象的生命周期产生影响，也无法通过引用来获取对象的实例。被回收的对象会被加入引用队列</li>
</ul>
<h2 id="怎么解决CPU100-的情况？"><a href="#怎么解决CPU100-的情况？" class="headerlink" title="怎么解决CPU100%的情况？"></a>怎么解决CPU100%的情况？</h2><h2 id="怎么解决full-GC频繁？"><a href="#怎么解决full-GC频繁？" class="headerlink" title="怎么解决full GC频繁？"></a>怎么解决full GC频繁？</h2><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><ul>
<li>加载</li>
<li>验证</li>
<li>准备</li>
<li>解析</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ul>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="为什么String不可变"><a href="#为什么String不可变" class="headerlink" title="为什么String不可变"></a>为什么String不可变</h2><p>1、String类是final型的<br>2、String内部使用char[]来存储数据，char[]也是final型的<br>不可变的好处:<br>1、可以缓存hash值。String经常需要比较，不可变的特性是hash只需要计算一次<br>2、String Pool的需要。String对象被创建后会缓存在String池中,当再有相同的String被创建时会直接使用String Pool中的字符串，只有String不可变才能使用String Pool<br>3、线程安全。不可变性具有天生的线程安全性  </p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举经过编译后会生成一个继承Enum的final类，且其属性是static final，因此enum是线程安全的。在序列化的时候只会将name结果输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。所以在接口中有返回枚举类型时需要特别注意，如果新增了枚举类型，需要先升级客户端.</p>
<h2 id="Class-forName-和ClassLoader-loadClass-有什么区别"><a href="#Class-forName-和ClassLoader-loadClass-有什么区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()有什么区别"></a>Class.forName()和ClassLoader.loadClass()有什么区别</h2><p>两者均可获取类的class对象，但Class.forName()在加载class的时候会执行其静态属性、静态块；</p>
<p>而ClassLoader仅仅加载类，不会执行其他内容</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>jdk动态代理:只能对实现了接口的类进行动态代理;<br>cglib动态代理:对目标类的处理，生成子类的字节码</p>
<h1 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h1><p>容器最主要有两类Collection和Map<br>Collection主要类如下:<br><img src="http://117.50.98.206/images/Collection.png" alt="image"><br>Map主要类如下:<br><img src="http://117.50.98.206/images/Map.png" alt="image"><br>重点关注几个面试中常常问到的类:</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList是一个线程安全的list，读写分离，读操作在原始数组中进行，写操作在副本数组中进行，写操作完成后替换原始数组<br>需要注意在写操作的时候会加锁<br>优点:写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景<br>缺点:</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap初始大小为16,每次扩容table长度为原来的两倍</p>
<p>扩容原理:<br>HashMap扩容有几个关键参数:</p>
<ul>
<li>capacity:table 的容量大小，默认为 16</li>
<li>size:键值对数量</li>
<li>threshold:size 的阈值，当 size 大于等于 threshold 就必须进行扩容操作</li>
<li>loadFactor:装载因子，table 能够使用的比例，threshold = (int)(newCapacity * loadFactor)</li>
</ul>
<p>JDK8开始table一个节点的长度大于8时会讲链表转化为红黑树</p>
<p>链表的时间复杂度是O(n)，红黑树的时间复杂度O(logn)，很显然，红黑树的复杂度是优于链表的。但是树节点所占空间是普通节点的两倍，所以只有当节点足够多的时候，才会使用树节点。  </p>
<p>jdk1.7hashmap<br>链表中的数据在进行resize时顺序会颠倒，因此会扩容时可能会产生<strong>环装链表</strong><br>jdk1.8hashmap<br>链表在resize时顺序不会颠倒<br>jdk1.7 concurrenthashmap<br>使用分段锁实现<br>jdk1.8 concurrenthashmap<br>在链表头结点上加锁实现，用reentranlock加锁  </p>
<p><strong>为什么扩容两倍？</strong><br>提高resize效率，扩容两倍的情况下元素要么在原来的位置，要么在原位置的基础上再移动2次幂的位置  </p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>jdk7中ConcurrentHashMap结构为多个segment,segment的个数既ConcurrentHashMap的并发度,每个segment都是一个数组+链表。扩容时对每个segment中的数组扩容，这样不会影响其他的segment  </p>
<p>jdk8其基本结构是数组加链表(红黑树)的结构,并发方面使用cas+synchronized来控制。扩容时table的长度会变为原来的两倍，这一步是单线程操作；由于jdk8中数组是同一个，因此在扩容时其他线程无法进行读写操作，所以此时的线程会帮助进行把元素复制到新数组的操作，ConcurrentHashMap中使用sizeCtl参数来标识是否在扩容/有多少线程在扩容。  </p>
<h1 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查看内存使用情况:free -m</span><br><span class="line">查看硬盘使用情况:df -h</span><br><span class="line">查看实时cup、内存情况:top</span><br><span class="line">(一般单cpu负载最好在0.7)</span><br><span class="line">查找java进程:jps</span><br><span class="line">通过pid找到端口: netstat -antup |grep $pid</span><br><span class="line">通过名称找pid: ps -ef|grep $name</span><br><span class="line">通过端口找pid: netstat -antup |grep $port</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Redis相关"><a href="#Redis相关" class="headerlink" title="Redis相关"></a>Redis相关</h1><h1 id="redis为什么快"><a href="#redis为什么快" class="headerlink" title="redis为什么快"></a>redis为什么快</h1><ul>
<li>redis是纯内存操作</li>
<li>redis采用了Nio的模型，是单线程的</li>
<li>redis是单线程了【事件派发器】，所以避免了线程切换</li>
</ul>
<h2 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h2><p>string、list、set、zset、hash</p>
<p>重点关注zset:<br>基本用法:zadd $keyname $socre $value<br>zset类似于java中的SortedSet和HashMap的结合体。他是一个set保证value的唯一性，另一方面它可以给每个value赋予一个score，代表value的排序权重  【1亿数据量找top10数据】</p>
<p>当一个zset的保存的元素数量小于128或新添加的元素小于64字节，zset底层使用ziplist结构，ziplist是一个线性接口，其value按照socore顺序排列，时间复杂度为O(N)；当元素数量大于128或新插入的元素大于64字节，zset底层使用skiplist，<strong>skiplist原理以后再补上</strong></p>
<h2 id="redis能用来干什么"><a href="#redis能用来干什么" class="headerlink" title="redis能用来干什么"></a>redis能用来干什么</h2><p>做缓存或者分布式锁/配合spring做分布式session</p>
<h2 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h2><p>redis分布式锁借助于setnx指令实现(set not exists),基本用法setnx $keyname $value，如果key不存在则能插入成功，key存在则插入失败。在程序中我们使用setnx尝试插入某个key，如果成功就执行业务操作，操作完成之后删除这个值；如果失败就再次尝试setnx，有点类似cas+自旋的操作。  </p>
<p>但这里其实有点问题，假如setnx设置了一个key之后，种种原因当前线程挂了，导致没有删除这个key，这样会导致死锁，于是在setnx的时候一般会给当前key加上一个过期时间(expire $key)  </p>
<p>但这里还是有个问题，由于setnx和expire不是原子操作，所以还是可能存在执行了setnx但没执行expire的情况，为了解决这种情况redis提供了set指令集(jedis也提供此参数)来解决这个问题，用法如下  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set keyname value ex 5 nx</span><br></pre></td></tr></table></figure>

<p>到这里还有一个问题，如果业务逻辑执行的时间过长，导致key已经过期了，这时其他线程就set key成功并执行业务了。</p>
<p>而超时线程在finally里删除key的时候可能会造成误删其他线程的锁，所以需要设置value为随机值，释放锁的时候调用lua脚本判断value是否一致，并删除锁</p>
<p>总之，redis分布式并不适合需要长时间处理的业务，如果真的出现这种情况可能需要人工干预修复数据。  </p>
<p>不管如何设置，不管用什么分布式锁来实现，都无法保证100%正确，无论超时时间设置多长，都有可能超时，所以最终是性能和正确性选择问题。</p>
<p>仔细想一起，其实只要依赖的中间件能够保证某个数据的唯一性，那么就可以把它当做分布式锁的工具。比如zk、redis、甚至数据库，只是基于效率考虑使用zk、redis做分布式锁的方案较为合理。</p>
<p>redis还有redission【三方包】和red lock【分布式】</p>
<p>zk用临时顺序节点的方式：监听前面一个临时节点是否创建成功。</p>
<h2 id="redis过期策略"><a href="#redis过期策略" class="headerlink" title="redis过期策略"></a>redis过期策略</h2><p>定时删除+惰性删除<br>redis每隔一段时间(100ms)会随机抽取一部分key来检查是否过期，如果过期就删除掉，这样的话必然有一部分过期的key没有被删除，这时就用上了惰性删除，也就是在获取key的时候还会判断key是否过期，如果过期就删掉</p>
<p>ps.为什么不直接删除过期的key，而采用一种随机删除的策略呢？因为如果key很多的话，遍历检查每个key是否过期会让cpu压力很大  </p>
<p>这样又会引出新的问题，这种情况下redis内存可能会持续增长，因此当内存不足时，redis有内存淘汰策略  </p>
<ul>
<li>noeviction:内存不足时插入新的数据报错</li>
<li>allkeys-lru:内存不足时，删除最少使用的key</li>
<li>allkeys-ranodm:内存不足时，随机删除key</li>
<li>volatile-lru:内存不足时，删除设置了过期的key中最少使用的</li>
<li>volatile-random:内存不足时，随机删除设置了过期时间的key</li>
<li>volatile-ttl:内存不足时，删除设置了过期时间的key中较早失效的key</li>
</ul>
<p>ps.LinkedHashMap可以方便的实现Lru缓存</p>
<h2 id="redis持久化方式"><a href="#redis持久化方式" class="headerlink" title="redis持久化方式"></a>redis持久化方式</h2><p> 1、aof:以日志的形式记录操作<br> &emsp;优点:<br>    &emsp;&emsp;1)、可以更好的保证数据不会丢失<br>    &emsp;&emsp;2)、日志文件写入速度快，且不容易损坏<br> &emsp;缺点:<br>    &emsp;&emsp;1)、日志文件通常比rdb文件更大<br>    &emsp;&emsp;2)、对性能有一定的影响<br> 2、rdb:每隔一段时间生成一个快照<br>    &emsp;优点:<br>    &emsp;&emsp;1)、能够从指定时间会恢复快照<br>    &emsp;&emsp;2)、恢复速度快<br>    &emsp;缺点:<br>    &emsp;&emsp;1)、由于定时备份，可能会缺少部分数据<br>    &emsp;&emsp;2)、RDB使用<code>fork()</code>产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒</p>
<p><strong>生产环境中通常组合使用</strong></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>事前:让redis高可用，避免缓存崩盘——主从+哨兵<br>事中:限流、服务降级<br>事后:redis持久化，快速恢复</p>
<h2 id="读写一致性问题"><a href="#读写一致性问题" class="headerlink" title="读写一致性问题"></a>读写一致性问题</h2><p>读:先读缓存，没有就查库，然后更新到缓存中<br>写:先删除缓存，然后更改数据库</p>
<h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><p>数据库事务隔离级别</p>
<ul>
<li>Read uncommitted 读未提交【读时不加锁，写时也不加锁】</li>
<li>Read committed 读已提交【读到数据时，加行共享锁；写数据时加行互斥锁】</li>
<li>Repeatable read 可重复读(默认)【读数据前，加行共享锁；写数据时，加行互斥锁】</li>
<li>Serializable 串行化【读数据前，加表共享锁；写数据时，加表互斥锁】</li>
</ul>
<p>可重复读是指，在事务1中查询到结果A，此时事务2向表中插入一条数据并提交，事务1再次查询，结果仍然是A  </p>
<h2 id="聚簇索引（Innodb）"><a href="#聚簇索引（Innodb）" class="headerlink" title="聚簇索引（Innodb）"></a>聚簇索引（Innodb）</h2><p>聚簇索引不是一种单独的索引类型，而是一种数据存储方式，它把当前行的数据与相邻行的数据存储在一起。在innodb数据引擎中，用主键聚集数据；如果没有则使用唯一非Null的索引代替，如果还没有则创建一个虚拟索引。  </p>
<p>优点：<br>访问速度更快。聚簇索引在可以在b树中同时保存索引和数据，因此比一般索引要快(这里也能知道索引中可能同时存数据和索引)<br>可以把相关的数据保存在一起，减少Io</p>
<p>缺点：<br>更新聚簇索引代价很高 </p>
<h1 id="B-树和B树的区别-B-树的优势"><a href="#B-树和B树的区别-B-树的优势" class="headerlink" title="B+树和B树的区别,B+树的优势"></a>B+树和B树的区别,B+树的优势</h1><p>B+树有两种类型的节点：内部节点(非叶子)不存储数据，只存储索引，数据都存储在叶子节点。<br>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</p>
<p>非叶子节点节点的索引值都冗余了一份在叶子节点里。</p>
<p>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。<br>父节点存有右孩子的第一个元素的索引。</p>
<p>B+树查询优势:</p>
<p>1、B+树中间节点不保存数据，一来磁盘页能容纳更多节点元素，</p>
<p>2、一个节点包含多个索引，二来降低树的高度</p>
<p>3、B+树范围查询更简单，而B树需要在叶子节点和内部节点之间来回移动。</p>
<p>4、特性保证新插入节点时，为了保证树的平衡性，旋转次数比较少。</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="spring生命周期"><a href="#spring生命周期" class="headerlink" title="spring生命周期"></a>spring生命周期</h2><p>spirng生命周期有几个关键的bean,按顺序如下</p>
<ul>
<li>InstantiationAwareBeanPostProcessor</li>
<li>BeanNameAware</li>
<li>BeanFactoryAware/ApplicationContextAware</li>
<li>InitializingBean</li>
<li>BeanPostProcessor</li>
<li>DeposableBean<br>大致流程为<ol>
<li>当通过getBean()方法调用容器中某个bean时，如果容器实现了InstantiationAwareBeanPostProcessor[IABPP]，那么就调用其实现类的postProcessBeforeInstantiation()–[pPBI]</li>
<li>调用bean的构造函数实例化该bean</li>
<li>容器实例化后，如果容器实现了InstantiationAwareBeanPostProcessor，那么调用其实现类postProcessAfterInstantiation()方法–[pPAI]</li>
<li>在设置属性之前，如果容器实现了InstantiationAwareBeanPostProcessor，那么调用其实现类postProcessPropertyValues()方法–[pPPP]</li>
<li>设置bean的属性</li>
<li>如果bean实现了BeanNameAware类，那么调用setBeanName()方法</li>
<li>如果bean实现了BeanFactoryAware/ApplicationContextAware，那么调用setBeanFactory()/setApplicationContext()</li>
<li>如果bean实现了InitializingBean,调用afterPropertiesSet()</li>
<li>bean如果是单例会给spring管理，不是则交给调用者管理f</li>
<li>容器销毁，如果bean实现了Disposable接口，则调用destory()</li>
</ol>
</li>
</ul>
<h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>hash算法种类</p>
<ul>
<li>传统hash算法:hashmap中的实现</li>
<li>一致性hash算法:【虚拟节点】</li>
<li>hash slot(hash槽)</li>
</ul>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p>kafka拓扑结构</p>
<p><img src="http://117.50.98.206/images/kafka_Topology.jpg" alt="kafka的拓扑图形"></p>
<p>broker:缓存代理，Kafka集群中的一台或多台服务器统称broker.</p>
<p>producer:向broker发送消息客户端</p>
<p>consumer:从broker获取消息的客户端</p>
<p>topic:消息的逻辑分区</p>
<p>consumer group:每个consumer只属于一个consumer group.<strong>一个topic可以被一个或多个consumer group订阅,一个消息会发送给所有订阅的consumer group,但在每个consumer group中只会被消费一次</strong><br>partition:消息的物理分区。partition是一个有序的队列，partition中每个消息都会有一个有序的id(offset).<strong>一个partition中的消息只会被一个consumer消费,但一个consumer可以消费多个partition中的消息，因此partition的数量要大于等于consumer的数量，</strong>否则会有消息无法被消费. kafka只保证在同一个partition中消息消费是有序的,但在不同partition中无法保证全局有序</p>
<p>partion最好为3的倍数</p>
<h2 id="kafka怎么为什么吞吐量高"><a href="#kafka怎么为什么吞吐量高" class="headerlink" title="kafka怎么为什么吞吐量高"></a>kafka怎么为什么吞吐量高</h2><ul>
<li><p>顺序读写</p>
</li>
<li><p>分区。每个partion中有多个segment，每次操作一小段segment</p>
</li>
<li><p>批量发送</p>
<p>写磁盘更快，因为每次写入只是将数据写入到操作系统的页缓存中，由操作系统负责写入，并且是追加写入，避免了磁盘随机写<br>读消息时，会首先尝试从页缓存中读取，如果命中则通过零拷贝技术直接发到socket上</p>
</li>
</ul>
<h2 id="kafka如何保证高可用"><a href="#kafka如何保证高可用" class="headerlink" title="kafka如何保证高可用"></a>kafka如何保证高可用</h2><p>kafka可以会对每个partion的数据保存一个副本，并从中选出一个Leader,producer发送消息的时候发送到leader，leader同步到各个follower；consumer消费消息的时候从leader读消息；当有节点挂掉时，数据可以从其他partion副本中恢复，这样保证了高可用  </p>
<h2 id="kafka如何保证消息不被重复消费"><a href="#kafka如何保证消息不被重复消费" class="headerlink" title="kafka如何保证消息不被重复消费"></a>kafka如何保证消息不被重复消费</h2><p>kafka的partion中的每个消息都有个offset的序号，当消息被消费且提交之后，证明这个消息已经被消费过了【一般是定时提交】；如果消息被消费，但并没有commit(比如进程被强制kill掉)，那么就可能出现消息重复消费的情况。这时可以在业务上做幂等处理来规避重复消费的问题  </p>
<h2 id="kafka怎么保证顺序"><a href="#kafka怎么保证顺序" class="headerlink" title="kafka怎么保证顺序"></a>kafka怎么保证顺序</h2><p>kafka能够保证在每个partion中的消息都是顺序消费的，因此要保证顺序性首先要个在发送消息的时候设置一个key(例如task_id)，这样相同的key的数据都会放到同一个partion中去，由于从partion中获取数据的时候是有顺序的，因此consumer这边如果是单线程消费，那么不存在顺序错乱的问题；如果consumer是多线程的，那么需要在consumer这边维护多个内存队列，消费时对key取hash并保存在内存队列中，目的是让同一个key的任务落到同一个内存队列中，这样多线程从多个内存队列中消费就能够保证有顺序了 </p>
<h2 id="kafka消息丢失问题"><a href="#kafka消息丢失问题" class="headerlink" title="kafka消息丢失问题"></a>kafka消息丢失问题</h2><p>1、消费端消息丢了<br>consumer消费消息之后就commit了，而并没有真正的处理完成，如果此时consumer宕机，那么就会发生消息丢失的情况，所以此时的解决办法是关闭自动提交，当conumser业务处理完成之后再commit<br>2、kafka消息丢了<br>当一个消息发送到一个partion的leader机器之后，leader还没有把此消息同步给follower时leader就宕机了，然后重新选举出了新的leader，consumer从新的leader开始获取消息，这是就发生了消息丢失的情况。此时可以通过kafka的一些配置来解决，具体上网搜一下</p>
<p><a href="%E6%9C%80%E5%B0%91%E8%A6%81%E8%AE%BE%E7%BD%AE4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A">^</a>: topic设置参数：replication.facotry&gt;1，要求每个partition至少有2个副本<br><a href="%E6%9C%80%E5%B0%91%E8%A6%81%E8%AE%BE%E7%BD%AE4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A">^</a>: kafka服务器设置参数:min.insync.replicas&gt;1，要求leader至少感知1台follower跟自己在数据同步<br><a href="%E6%9C%80%E5%B0%91%E8%A6%81%E8%AE%BE%E7%BD%AE4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A">^</a>: producer端设置参数:acks=all，要求每条消息写入到所有副本之后才返回写入成功<br><a href="%E6%9C%80%E5%B0%91%E8%A6%81%E8%AE%BE%E7%BD%AE4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A">^</a>: producer端设置参数reties=一个很大的数，要求写入不成功则重试</p>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>当考虑到同时修改一条记录时即要考虑分布式事务的问题  </p>
<h2 id="两段式-PC"><a href="#两段式-PC" class="headerlink" title="两段式(PC)"></a>两段式(PC)</h2><p>适合在一个应用中对多个数据库进行操作的场景【现在微服务架构一般不允许】，可以seata中间件协助解决，基本原理是在操作一条数据库时会同时往todo_log表中插入数据用于记录原始信息，两张表都操作成功则开始进行第二个库的操作，若第二个库操作失败，则通过todo_log表回滚数据  </p>
<h2 id="三段式-TCC"><a href="#三段式-TCC" class="headerlink" title="三段式(TCC)"></a>三段式(TCC)</h2><p>适合需要多个系统协作的场景，可以使用Himily中间件协助解决，在tcc各阶段均需要借助日志表 。</p>
<p>插入数据的同事，插入日志表，对本次操作日志打上标志，等待下游的返回，返回成功再把操作日志改为成功，每个节点都成功才算成功，中间一个环节失败，都失败</p>
<h2 id="最终一致性-利用消息中间件"><a href="#最终一致性-利用消息中间件" class="headerlink" title="最终一致性(利用消息中间件)"></a>最终一致性(利用消息中间件)</h2><p>即利用利用消息中间件的特性来保证一定能够发送成功，但具体问题比较多，以后完善。</p>
<p>分布式事务的问题还需要注意幂等、空回滚等等问题 。</p>
<h1 id="Dubbo的工作流程和原理"><a href="#Dubbo的工作流程和原理" class="headerlink" title="Dubbo的工作流程和原理"></a>Dubbo的工作流程和原理</h1><h2 id="分10层：里面上面六层在dubbo工作中所扮演的角色。"><a href="#分10层：里面上面六层在dubbo工作中所扮演的角色。" class="headerlink" title="分10层：里面上面六层在dubbo工作中所扮演的角色。"></a>分10层：里面上面六层在dubbo工作中所扮演的角色。</h2><p>Service层:需要提供接口给用户实现自己的方法。</p>
<p>Config层:项目中配置的dubbo-consumer.xml和dubbo-server.xml</p>
<p>Proxy层：提现在ServiceBean的afterProperitesSet方法里导出服务端代理Invoker和ReferenceBean的afterPropertiesSet方法创建客户端调用Invoker</p>
<p>Registry层:体现在注册中心</p>
<p>Cluster层:集群</p>
<p>Monitor层:监控平台</p>
<p>Protocol层:</p>
<p>Exchange层:</p>
<p>Transport层:</p>
<p>序列化层:</p>
<h2 id="注册中心挂了，provider和consumer还可以继续通信么？"><a href="#注册中心挂了，provider和consumer还可以继续通信么？" class="headerlink" title="注册中心挂了，provider和consumer还可以继续通信么？"></a>注册中心挂了，provider和consumer还可以继续通信么？</h2><p>可以，因为初始化的时候，consumer会将provider的地址等信息拉取到本地缓存,consumer可以字节给provider发。</p>
<h1 id="Dubbo泛化调用"><a href="#Dubbo泛化调用" class="headerlink" title="Dubbo泛化调用"></a>Dubbo泛化调用</h1><p>泛化机制，和普通的rpc调用有一些不同，它不需要引入各个依赖服务的jar包，调用方如果知道接口方法的具体信息：名称，版本，参数类型等，就可以完成rpc调用。</p>
<p>消费端在底层实现上并没有什么区别，泛化调用和普通调用,实现分支是不同的。基于泛化机制的调用，其首先会对入参进行解析，构造和普通调用一样的<code>RpcInvocation</code>对象，然后执行具体实现方法，包装结果返回。</p>
<p>泛化调用会存在多一次序列化的操作，如代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">args = PojoUtils.realize(args, params, method.getGenericParameterTypes());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这个方法的作用:如果存在请求参数类型和具体执行method的参数不一致时，则进行兼容转换到正确的参数类型，完成调用。</span></span><br><span class="line"><span class="comment">所以，当我们通过泛化传来”12345678”的时候，可以自动转换为long类型，但是如果参数是”E12345678”,则自动转换就会失败，抛出异常。*/</span></span><br></pre></td></tr></table></figure>



<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="饿汉模式，代码如下，不存在线程安全问题，但是没有延迟加载。"><a href="#饿汉模式，代码如下，不存在线程安全问题，但是没有延迟加载。" class="headerlink" title="饿汉模式，代码如下，不存在线程安全问题，但是没有延迟加载。"></a>饿汉模式，代码如下，不存在线程安全问题，但是没有延迟加载。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;`</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​			<span class="keyword">return</span> INSTANCE;</span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>





<h2 id="懒汉模式，延迟加载，但是存在，线程安全问题，用DCL解决"><a href="#懒汉模式，延迟加载，但是存在，线程安全问题，用DCL解决" class="headerlink" title="懒汉模式，延迟加载，但是存在，线程安全问题，用DCL解决"></a>懒汉模式，延迟加载，但是存在，线程安全问题，用DCL解决</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;`</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">private</span> <span class="keyword">static</span>  Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​			<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">​				instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">​			&#125;</span><br><span class="line"></span><br><span class="line">​			<span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>

<h2 id="懒汉模式，DCL版本"><a href="#懒汉模式，DCL版本" class="headerlink" title="懒汉模式，DCL版本"></a>懒汉模式，DCL版本</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;`</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">private</span> **<span class="keyword">volatile</span>** <span class="keyword">static</span>  Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">​			<span class="keyword">synchronized</span>(instance)&#123;</span><br><span class="line"></span><br><span class="line">​				<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">​					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">​				&#125;</span><br><span class="line"></span><br><span class="line">​			&#125;</span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>

<h2 id="静态内部类，可以称为最佳方案"><a href="#静态内部类，可以称为最佳方案" class="headerlink" title="静态内部类，可以称为最佳方案"></a>静态内部类，可以称为最佳方案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;`</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​			<span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>

<h2 id="枚举，永远单例"><a href="#枚举，永远单例" class="headerlink" title="枚举，永远单例"></a>枚举，永远单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;`</span><br><span class="line"></span><br><span class="line">​	INSTANCE;</span><br><span class="line"></span><br><span class="line">`&#125;`</span><br></pre></td></tr></table></figure>

<h1 id="补充"><a href="#补充" class="headerlink" title="补充:"></a>补充:</h1><p><strong>nio原理</strong> </p>
<p>selector注册监听器【服务端注册感兴趣的事件，然后轮询是否有收到相应的事件。客户端发起服务端感兴趣的事件，服务端的selector轮询到了，则会处理】</p>
<p>BIO在accept()和read()的时候会阻塞【阻塞说明会让出CPU】</p>
<p><strong>AQS原理</strong></p>
<p>一个用来实现同步锁以及其他涉及到同步功能的核心组件。</p>
<p>AQS是一个抽象类，主要是通过继承的方式来使用，它本身没有实现任何的同步接口，仅仅是定义了同步状态(state)的获取以及释放的方法来提供自定义的同步组件。</p>
<p>他的实现原理：定义了一个同步状态，state=0，线程来获取锁的时候，会用CAS的方式，尝试将state改成1，如果成功，则获取锁，执行业务代码。如果失败，则进入同步队列。获取到锁的线程执行完业务代码，会来唤醒同步队列中的线程。</p>
<p>公平锁和非公平锁执行的逻辑唯一的不同是，公平锁会尝试获取锁之前会检查一下同步队列是否为空，如果不为空，则排队。而非公平锁，则直接尝试获取锁。</p>
<p><strong>redis命令</strong></p>
<p><strong>zset的用法，1亿数据，取top10</strong></p>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a><strong>类加载机制</strong></h1><p><strong>类加载的时机</strong></p>
<ul>
<li>new 创建类的实例【隐式加载】</li>
<li>loaderClass,forName等【显式加载】</li>
<li>访问类的静态变量，或者为静态变量赋值</li>
<li>调用类的静态方法</li>
<li>使用反射方式创建某个类或者接口对象的Class对象。</li>
<li>初始化某个类的子类</li>
<li>直接使用java.exe命令来运行某个主类</li>
</ul>
<p><strong>在JVM中标识两个Class对象，是否是同一个对象存在的两个必要条件</strong></p>
<p>类的完整类名必须一致，包括包名。</p>
<p>加载这个ClassLoader（指ClassLoader实例对象）必须相同。</p>
<p><strong>双亲委任模型**</strong>工作原理:**</p>
<p>如果一个类收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行，如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最后到达顶层的启动类加载器，如果父类能够完成类的加载任务，就会成功返回，倘若父类加载器无法完成任务，子类加载器才会尝试自己去加载，这就是双亲委派模式。【就是每个儿子都很懒，遇到类加载的活都给它爸爸干，直到爸爸说我也做不来的时候，儿子才会想办法自己去加载。】</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>注意，ThreadLocalMap的⽣命周期跟Thread的⽣命周期是⼀样的，在某些特定条件下可能会导致内存泄漏。</p>
<p>具体来说，ThreadLocalMap中的ThreadLocal引⽤虽然是弱引⽤，<strong>即ThreadLocal对象本身如果不再存在任何强引⽤的情况下，在下次GC的时候便会被JVM回收，但是因为有ThreadLocalMap的存在，考虑到它的⽣命周期跟Thread相同，如果Thread 没有被回收，则ThreadLocal中的对象，即Entry的value对象未必会被回收</strong>。</p>
<p>当然，从JDK的源码中我们可以 发现，当触发对ThreadLocal对象进⾏get或set操作时，会对Map中的应当被清理的对象进⾏清理，这也是⾮常重要的⼀点，就是这个Map是 被动删除的，如果你创建了很多ThreadLocal对象，⼜不对其进⾏读写，那么其中的value就会因为⼀直有强引⽤的存在（Thread对象到这个value之间是可达的，GC不会将其回收）⽽ 导致⽆法被回收，这就是ThreadLocal可能会导致内存泄漏的原因。这个问题的出现基本上都跟线程池的使⽤ 有关，因为线程池中的线程在执⾏完任务之后会回到池中，⼀般会在应⽤关闭时才会被回收，这就导致 ThreadLocal对象中的value对象⼀直占⽤着内存。</p>
<p>在线程池中使⽤ThreadLocal还有个需要注意的地⽅，就是如果ThreadLocal中存的对象跟线程要执⾏的任务 有关，则可能导致ThreadLocal中保存的value串掉。为什么呢？因为线程池中同⼀个线程可能会执⾏很多个 任务，如果ThreadLocal中保存的对象没有被及时remove掉，那么之后取到的对象就是错误的。</p>
<h1 id="保镖的问题"><a href="#保镖的问题" class="headerlink" title="保镖的问题"></a>保镖的问题</h1><p>关闭activiti的日志，</p>
<p>pid</p>
<p>单表超过7500W，引入mycat分库分表。</p>
<h1 id="口碑面试问题"><a href="#口碑面试问题" class="headerlink" title="口碑面试问题"></a>口碑面试问题</h1><p>场景问题，新建表，用户表、消费账单表，银行卡表。</p>
<p>对用户表进行分库分表，</p>
<p>评估客户数量确定每次发多少条，可以分首字母对客户进行分类，</p>
<p>账单也是按时间分前后。</p>
<p>发送内容用 velocity渲染。</p>
<p>用户表还需要ES，用于查询用户的首字母。</p>
<p>银行卡</p>
<p>多线程发送，可以加上线程池</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">叶中中</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/09/01/Java%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/">http://yoursite.com/2020/09/01/Java%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">old engineer</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="http://117.50.98.206/images/wallpaper_drop_ocean.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/09/01/hello-world/"><img class="next-cover" src="http://117.50.98.206/images/wallpaper_drop_ocean.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 叶中中</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>